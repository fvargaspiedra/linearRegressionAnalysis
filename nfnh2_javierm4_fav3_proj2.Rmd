---
title: "Prediction of House Prices in Ames, Iowa Using Regression Analysis Techniques"
author: "Hari Manan (NetID: nfnh2), Javier Matias (NetID: javierm4), Francisco Vargas (NetID: fav3)"
date: 'August 3rd, 2018'
output:
  html_document: 
    toc: yes
  pdf_document: default
urlcolor: cyan
---
```{r message=FALSE, echo=FALSE}
#options("scipen"=100, "digits"=4)
```

```{r setup, include=FALSE}
library(knitr)
library(jtools)
library(ggplot2)

#knitr::opts_chunk$set(echo = TRUE)
#options(digits=8)
knit_hooks$set(htmlcap = function(before, options, envir) {
  if(!before) {
      paste('<p style="text-align: center;" class="caption">',options$htmlcap,"</p>",sep="")
    }
})
```

## Introduction

### Sale Price Prediction Model

The main goal of this study is to develop a model to predict the sale price of a house. A well performing model should provide an acceptable level of predictive accuracy while using only a limited number of features with the aim of reducing complexity and overfitting. A model of reduced size seeks to acheive a useful balance between the prediction and explanation goals.

### Effect of Neighborhood on Living Area Price

For this study, we will also perform some exploratory data analysis to explain how the effect of a continous predictor on the response varies across different treatment groups of a categorical predictor. Namely, we'll test:

$H_0: \beta_{j,LivArea:Neighborhood} = 0, \forall j \text{ - The mean price per square foot of a house is the same for every neighborhood j }$

$H_1: \beta_{j,LivArea:Neighborhood} \neq 0,  \forall j \text{ - At least one neighborhood j has a different mean price per square foot than others }$,

using a confidence level of $\alpha= 0.01$.

We will also attempt to infer which neighborhoods place the highest monetary values on living area and determine whether the living area predictor is collinear with other predictors.

### Housing Dataset

To develop the model, we will use a dataset describing houses sold between 2006 and 2010 in Ames, Iowa. This data set was compiled by Dean DeCock in 2011, and it provides over 2800 observations with 81 features (23 nominal/categorical, 23 ordinal, 14 discrete, and 21 continuous).

The features can be roughly divided into 6 categories.

- **House characteristics**: e.g. number of bedrooms, number of bathrooms, electrical system
- **Space measurements**: e.g. lot area, living area
- **Quality ratings**: e.g. overall condition, kitchen condition
- **Construction characteristics and materials**: e.g. roof material
- **Zone and location classification**: e.g. zoning classification, neighborhood
- **Terms of sale**: e.g. month and year sold, sale price

There are several reasons why the team decided to use this dataset and why this is interesting to us. Most of them are related to research and personal motivations and are enumerated below:

1. **Model simplification**: This dataset offers many variables. Even though accuracy tends to improve as the number of predictors increases, larger models also increase complexity and become more difficult to interpret. Complex models are also highly succeptible to overfitting. The goal of this project is to derive a model using a subset of the predictor variables while achieving a comparable level of performance.
2. **Cleanness**: The dataset is well curated and does not require extensive cleansing. This will allow the team to focus on analyzing the data itself.
3. **Questions**: From a personal interest perspective, this dataset is related to a frequent activity: buying a house. This is a well-known activity that allows for some interesting questions:
    - **How effectively can we predict the price of a house given a set of explanatory variables?** A test/training set evaluation process can help us measure the accuracy under acceptable error ranges. This could give us some insight to answer other questions such as: *"Does the time of year affect the sale price of the house?"*
    - **Can we identify unusual observations that might be affecting the model?** Understanding leverage, outliers, and influential points in the model will allow us to identify unusual observations in our regressions model.
    - **Are there any interactions between the variables affecting the price of the houses?** Experimenting with dummy variables and interaction models might help answer questions such as: *"Do some neighborhoods value having a pool or a garage more than others?"*
    - **What are the most influential predictors?** Hypothesis tests might be the best path in this case.
    - **Can we build a reduced version of the model without sacrificing accuracy?** Use variable selection procedures, collinearity, and ANOVA evaluation to find a good model for the housing dataset from a set of possible models.
    - **Are transformations necessary to improve the accuracy of the model?** Transformation techniques and assumption tests might lead us to the answer.

## Methods

### Data Cleaning

We will begin by loading the housing data stored in `AmesHousing.csv`.

```{r message=FALSE}
library(readr)
housing_data = read_csv("data/AmesHousing.csv")
```

There are two variables that do not describe house qualities. `PID` is the unique identifier of each observation and `Order` is a counter for each observation.

```{r}
### Remove non-relevant variables
housing_data = subset(housing_data, select = -Order)
housing_data = subset(housing_data, select = -PID)
```


Next, we'll inspect the strucutre of the dataset.
```{r}
dim(housing_data) ## Dimension of the dataset.
table(sapply(housing_data, class)) ## Variable types
```

We can observe that the dataset is composed by 2930 observations and 80 variables. There are only `character` and `integer` variables. A description of each variable can be found at: https://ww2.amstat.org/publications/jse/v19n3/decock/DataDocumentation.txt. 

#### Null Values

We'll examine whether there are `NA` values in the dataset and decide how to manage them.

```{r}
hasNA = colSums(is.na(housing_data))[colSums(is.na(housing_data)) > 0]
hasNA
```

`r length(hasNA)` variables contain `NA` values. Some of those variables have a high number `NA`s, therefore we decided to remove any variable with more than 400 `NA`s. The 400 value was chosen as a threshold because it was a good division between variables with many `NA`s and variables with managable numbers of `NA`s:

```{r}
# Keep only those variables that has less than 400 NAs 
housing_data = subset(housing_data, select = colSums(is.na(housing_data)) < 400)
```

After filtering, we now have `r dim(housing_data)[1]` observations and `r dim(housing_data)[2]` variables.

In order to avoid any issues with the remaining observations that have `NA`s we are removing those as well:

```{r}
housing_data = na.omit(housing_data)
```

After filtering, we now have `r dim(housing_data)[1]` observations and `r dim(housing_data)[2]` variables.

#### Unusual Observations

We started by inspecting the most reasonable relations to explain sale price. By plotting `SalePrice` (price of the house) vs `Gr Liv Area` (above ground living area square feet) it's noticeable that there are 5 points that are outliers:

```{r fig.height=5, fig.width=10}
plot(housing_data$SalePrice ~ housing_data$`Gr Liv Area`,
     col = ifelse(housing_data$`Gr Liv Area` > 4000, "orange", "dodgerblue"),
     xlab = "Ground Living Area (square feet)",
     ylab = "Sale Price (US Dollars)",
     main = "Sale Price vs Ground Living Area",
     pch = 20,
     cex = ifelse(housing_data$`Gr Liv Area` > 4000, 2, 0.7)
     )
```

Based on the plot, we observe 3 points that have an extremely low price for a huge ground living area. There are other two points that belong to a high range of prices without enough samples which we are also removing.

```{r}
## Remove observations with living area larger than 4000 sq ft.
housing_data = housing_data[housing_data$`Gr Liv Area` < 4000, ]
```

We also note that two neighborhoods have less than 3 observations. A sample size smaller than 3 for a categorical group is not sufficiently large to derive meaningful estimates.

```{r}
table(housing_data$Neighborhood)

## Remove observations belonging neighborhoods smaller than 3
housing_data = housing_data[-which(housing_data$Neighborhood %in% c("GrnHill","Landmrk")),]
```

Lastly, it is necesary to coerce all character columns as factors to fit the categorical predictors of the model:

```{r}
# Determine variables that are of type character
char_var = lapply(housing_data, class) == "character"
# Coerce those columns to factor
housing_data[, char_var] = lapply(housing_data[, char_var], as.factor)
```

### Baseline analysis for predictive model

As stated in the `Introduction` the goal of the project is to obtain a model for predicting sales price, but trying to keep it simple. In other words, finding a good balance between prediction and explanation.

Before playing around with model selection, let's divide the data into a training and a test set. That will help us evaluate the final model chosen. We'll use the seed `420` for any random process so we can reproduce the results if needed.

```{r}
set.seed(420)

# Get training indexes randomly (80% of the observations)
train_index <- sample(seq_len(nrow(housing_data)), size = floor(0.8 * nrow(housing_data)))

# Divide the data
train_hd <- housing_data[train_index, ]
test_hd <- housing_data[-train_index, ]

# We are removing a conflicting observation for "Kitchen Qual" that is only present on the test set
# This is because there is only one observation with that value
test_hd = test_hd[-which(test_hd$`Kitchen Qual` == "Po"),]
```

After splitting the data we now have `r dim(train_hd)[1]` observations for training and `r dim(test_hd)[1]` observations for test.

In order to assess our models we are going to use the set of auxiliary functions defined on week's 9 assignment. We are also defining a macro function that calls all those auxiliary functions and show the results in a single call. This overview encompasses the p-value of the normality and constant variance assumptions through Shapiro and Breusch test, the Fitted vs Residuals plot, the normal Q-Q plot, the number of parameters used (betas), the LOOCV RMSE, and the adjusted $R^2$.

```{r message=FALSE, warning=FALSE}
# Library required for Breusch-Pagan test
library(lmtest)

# Plot Fitted vs Residuals
plot_fitted_resid = function(model) {
  plot(fitted(model), resid(model), 
       col = "dodgerblue", pch = 20, cex = .7,
       xlab = "Fitted", ylab = "Residuals",
       main = "Fitted vs residuals plot")
  abline(h = 0, col = "darkorange", lwd = 1)
}

# Plot Normal Q-Q
plot_qq = function(model) {
  qqnorm(resid(model), col = "dodgerblue", pch = 20, cex = .7)
  qqline(resid(model), col = "darkorange", lwd = 1)
}

# Breusch-Pagan test (constant variance)
get_bp_decision = function(model) {
  bptest(model)$p.value
}

# Shapiro-Wilk test (normality)
get_sw_decision = function(model) {
  shapiro.test(resid(model))$p.value
}

# Number of parameters
get_num_params = function(model) {
  length(coef(model))
}

# LOOCV RMSE
get_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

# Adjusted R^2
get_adj_r2 = function(model) {
  summary(model)$adj.r.squared
}

# Function that combines the previously defined functions
get_overview = function(model) {
  par(mfrow=c(1,2)) #Plot two graphs in the same image
  plot_fitted_resid(model)
  plot_qq(model)
  loocv_rmse = get_loocv_rmse(model)
  adj_r2 = get_adj_r2(model)
  bp_p_value = get_bp_decision(model)
  shapiro_p_value = get_sw_decision(model)
  betas = get_num_params(model)
  list(loocv_rmse = loocv_rmse, adj_r2 = adj_r2, bp_p_value = bp_p_value, shapiro_p_value = shapiro_p_value, betas = betas)
}

append_to_result_dataframe = function(df1, model, log_response = TRUE , name) {
  
  train_fitted_values = fitted(model)
  if(log_response) {
    train_fitted_values = exp(train_fitted_values)
  }
  test_fitted_values =  predict(model, newdata=test_hd)
  if(log_response) {
    test_fitted_values = exp(test_fitted_values)
  }
  rmse_train = sqrt(mean((train_hd$SalePrice - train_fitted_values)^2))
  rmse_test = sqrt(mean((test_hd$SalePrice - test_fitted_values)^2))
  
  columns = c("Model Description","Train RMSE", "Test RMSE","Number of Coefficients")
  
  if(is.null(df1)) {
    df = data.frame( desc=c(name),rmsetrain=c(rmse_train),rmsetest=c(rmse_test),
                                coefs=c(length(coef(model))))
    colnames(df) = columns
    
    return(df)
  }
  else {
    df2 = data.frame(name, rmse_train, rmse_test, length(coef(model)))
    names(df2) = columns
    newdf = rbind(df1, df2)
    return(newdf)
  }
}
```

We can start the process of finding our model by using an additive model as a baseline:

```{r message=FALSE, warning=FALSE}
model_add = lm(SalePrice ~ ., data = train_hd)

## Dataframe to capture all performance results.
model_performance = append_to_result_dataframe(NULL, model_add,
                                               log_response = FALSE,
                                               name="Additive Model")
```

Let's run the overview function to assess this baseline model:

```{r fig.height=5, fig.width=10}
get_overview(model_add)
```

From the results above you can note that there are troubles on every resulting parameter, except the adjusted $R^2$. LOOCV RMSE is `inf` (because there are hat values equal to 1), both assumptions are violated (p-values are very low), and the number of parameters used is huge (because of the categorical variables, we end up having more betas than the number of predictors available). The Fitted vs Residuals plot also seems to violate both, the 0 mean at any fitted value and the constant variance at any fitted value (no linearity and no constant variance).

Based on the normal Q-Q plot is evident that there is a huge deviation at the edges of the plot. We can apply a log transformation on the response and check whether this minimizes the effect:

```{r fig.height=5, fig.width=10}
model_add_log = lm(log(SalePrice) ~ ., data = train_hd)

model_performance = append_to_result_dataframe(model_performance,model_add_log,
                                               log_response = T,
                                               name="Additive Log Response")
get_overview(model_add_log)
```

The Shapiro's p-value is worse, but the normal Q-Q plot looks better. This can be due to some outliers that can be observed on the plot. 

The outliers can be identified by using `plot` function:

```{r fig.height=10, fig.width=10, warning=FALSE}
par(mfrow=c(2,2))
plot(model_add_log, cex=.7, col="dodgerblue")
```

From the resulting plots we can see that observations `1682`, `578`, and `213` seem to be outliers. Let's remove them:

```{r fig.height=5, fig.width=10}
train_hd = train_hd[-c(1682, 578, 213),]
model_add_log = lm(log(SalePrice) ~ ., data = train_hd)
model_performance = append_to_result_dataframe(model_performance,model_add_log,
                                               log_response = T,
                                               name="Additive Log Response, Outliers Removed")
get_overview(model_add_log)
```

It now looks a bit better, but there is still a noticeable violation of normality at the edges. The Fitted vs Residuals plot also looks better, especially the 0 mean at any fitted value.

We tried to find outliers or influential points, but using the heuristics of the book is not possible to find any:

```{r}
# Number of influential points in the transformed model
sum(cooks.distance(model_add_log) > 4 / length(cooks.distance(model_add_log)))

# Number of outliers in the transformed model
sum(abs(rstandard(model_add_log)) > 2)
```

We can also see the positive effect of the `log` function in the response by looking at its histogram. Without `log`:

```{r}
hist(train_hd$SalePrice, 
     breaks = 30,
     main = "Histogram of Sale Price without transformation",
     xlab = "Sale Price",
     col = "gray")
```

As you can see this plot is right skewed. This can be normalized by using `log`:

```{r}
hist(log(train_hd$SalePrice), 
     breaks = 30,
     main = "Histogram of Sale Price with log transformation",
     xlab = "Sale Price",
     col = "gray")
```

We can notice that the obtained plot is much better and the `log` transformation makes sense for the response.

Let's use this transformed additive model as our baseline. There are still many paramaters that can be improved.

### Selection methods for predictive model

There are many predictors to play with. We can try to choose a smaller base of "relevant" numerical predictors and then assess the addition of categorical variables through a `forward` process.

One way of doing this is by selecting those numerical predictors that are highly correlated to the response.

```{r}
# Get correlation list of all numerical variables against Sale Price
sale_price_cor = cor(train_hd[sapply(train_hd, is.numeric)])[,"SalePrice"]
sale_price_cor
```

```{r htmlcap=""}
# Get correlation list of all numerical variables against Sale Price
data_cor = train_hd[sapply(train_hd, is.numeric)]

# use Spearman's correlation
corr <- cor(data_cor, method="spearman", use="pairwise.complete.obs")

# order by hierarchical clustering
o <- hclust(as.dist(1-corr))$order

library(qtlcharts)


iplotCorr(data_cor, corr=corr[o,o], reorder=TRUE, chartOpts=list(scatcolors="lightblue", cortitle="Correlation matrix", scattitle="Scatterplot", caption=paste("Click on the heatmap on the left to see", "corresponding scatterplots on the right.")))


```

We can then remove those values that are low in magnitude. We'll choose a threshold of 0.4:

```{r}
# Filter correlations with magnitude smaller than a specified threshold
sale_price_cor = sale_price_cor[abs(sale_price_cor) > 0.4]
sale_price_cor
```

We now have a smaller group of numerical predictors to choose from. By reading the documentation of this set of parameters one can see that some of them are the result of the others or are very related. This obviously leads to collinearity issues.

We used the whole correlation matrix to compare between those predictors that we thought had a relation to decide which to keep and which to remove:

```{r}
# Get correlation list of all numerical variables against Sale Price
cor(train_hd[,names(sale_price_cor)])
```

Based on the previous matrix, `Year Built` and `Year Remod/Add` are correlated. If there was no remodelation the year built is used on `Year Remod/Add`, so let's keep `Year Remod/Add` only. 

`BsmtFin SF 1` and `Total Bsmt SF` are also correlated. Let's keep `Total Bsmt SF` which has a higher correlation with SalePrice. Same happens with `1st Flr SF` and `Gr Liv Area`, we'll keep `Gr Liv Area`.

There are also 3 numerical variables related to the garage. The `Garage Cars` seems to be the most relevant.

We can now simplify our `sale_price_cor` vector with the chosen variables:

```{r}
# Auxiliary vector with names
var = names(sale_price_cor)

sale_price_cor = sale_price_cor[var != "Year Built" & var != "BsmtFin SF 1" & var != "1st Flr SF" & var != "Garage Yr Blt" & var != "Garage Area"]

sale_price_cor
```

Let's fit a model with the chosen numerical variables and finish the collinearity study using `vif` analysis. Don't forget that we are transforming the response using `log`.

```{r, message=FALSE, warning=FALSE}
# Fit a simple additive model with the chosen numerical variables
model_add_num = lm(log(SalePrice) ~ ., data = train_hd[, names(sale_price_cor)])

# Run vif test
library(faraway)
vif(model_add_num)
```

There are no values over 5 which is the heuristic used in the course book that should cause concern. It seems that we removed the right numerical variables.

We can apply the `get_overview` function to evaluate assumptions as well:

```{r fig.height=5, fig.width=10}
model_performance = append_to_result_dataframe(model_performance,model_add_num,
                                               log_response = T,
                                               name="Categorical Predictors Removed")

get_overview(model_add_num)
```

Everything looks similar to the additive model using all the predictors. This time the LOOCV RMSE is not `inf` (no hat values of 1).

Let's now check whether transforming any of these predictors makes sense. A visual inspection of `pairs` plot might suggest possible transformations.

```{r fig.height=8, fig.width=10}
pairs(train_hd[, names(sale_price_cor)], pch=20, cex=.5)
```

Based on this output, it seems that trying a `log` transformation on `Gr Liv Area` and `Total Bsmt SF` can make sense to soften the effect ot extreme values:

```{r fig.height=5, fig.width=10, message=FALSE, warning=FALSE}
model_add_num_log = lm(log(SalePrice) ~ `Overall Qual` + `Year Remod/Add` + `Mas Vnr Area` + log(`Total Bsmt SF`) + log(`Gr Liv Area`) + `Full Bath`  + `TotRms AbvGrd` + `Fireplaces` + `Garage Cars`, data = train_hd)

get_overview(model_add_num_log)

model_performance = append_to_result_dataframe(model_performance,model_add_num_log,
                                               log_response = T,
                                               name="Additive, Log Response, Log Predictors")


```

After the transformation the assumption parameters improved and the rest remain almost the same. We can keep these changes.

Let's now try to simplify the model using a backward selection procedure and AIC.

```{r fig.height=5, fig.width=10}
model_add_num_log_back = step(model_add_num_log, direction = "backward", trace = 0)
model_add_num_log_back$coefficients
get_overview(model_add_num_log_back)

```


```{r message=FALSE, warning=FALSE}
model_performance = append_to_result_dataframe(model_performance,model_add_num_log_back,
                                               log_response = T,
                                              name="Backward Search")
```


The number of rooms above the ground were removed from the model. Let's confirm that this is not a significant removal using an ANOVA test:

```{r}
p_val = anova(model_add_num_log_back, model_add_num_log)$"Pr(>F)"[2]
p_val
```

We failed to reject the null hypothesis for any reasonable significance level, which means that the simplified model can be used and the number of rooms above ground were not significant. We now have only 9 numerical variables.

Let's see whether this model can be improved by adding categorical variables. This can be done using a forward selection procedure and BIC to get the smaller possible model:

```{r message=FALSE, warning=FALSE}
# The scope includes all the filtered numerical variables plus all the available categorical variables

model_add_mix = step(model_add_num_log_back, direction = "forward",
                     scope = SalePrice ~ `Overall Qual` + `Year Remod/Add` + `Mas Vnr Area` 
                     + log(`Total Bsmt SF`) + log(`Gr Liv Area`) + `Full Bath` + `Fireplaces` 
                     + `Garage Cars` + Street + `MS SubClass`  + `MS Zoning` + `Lot Shape` + `Land Contour` 
                     + Utilities + `Lot Config` + `Land Slope` 
                     + Neighborhood + `Condition 1` + `Condition 2` + `Bldg Type` + `House Style` + `Roof Style`
                     + `Roof Matl` + `Exterior 1st` + `Exterior 2nd` + `Mas Vnr Type` + `Exter Qual` 
                     + `Exter Cond`  + Foundation + `Bsmt Qual` + `Bsmt Cond` + `Bsmt Exposure` 
                     + `BsmtFin Type 1`  + `BsmtFin Type 2` + Heating + `Heating QC` 
                     + `Central Air` + Electrical 
                     + `Kitchen Qual`  + Functional + `Garage Type` 
                     + `Garage Finish` + `Garage Qual` + `Garage Cond` + `Paved Drive` 
                     + `Sale Type` + `Sale Condition`,
                     k = log(length(resid(model_add_num_log_back))),
                     trace = 0)

model_performance = append_to_result_dataframe(model_performance, model_add_mix,
                                               log_response = T,
                                              name="Forward Categorical Predictor Search")

test_fitted_values =  predict(model_add_mix, newdata=test_hd)
rmse_test = sqrt(mean((test_hd$SalePrice - test_fitted_values)^2))

```

We can now run our diagnostics for the obtained model:

```{r fig.height=5, fig.width=10}
get_overview(model_add_mix)
```

The assumptions plots remain the same. There is a noticeable improvement on adjusted $R^2$ and our LOOCV RMSE is `inf` again. This is due to some hat values being 1. Let's explore how many we have:

```{r}
sum(hatvalues(model_add_mix) == 1)
```

Since the number of conflicting hat_values is so low we can simply ignore them and calculate LOOCV RMSE manually:

```{r}
loocv_rmse_final_mod = sqrt(mean((resid(model_add_mix)[-which(hatvalues(model_add_mix) == 1)] / (1 - hatvalues(model_add_mix)[-which(hatvalues(model_add_mix) == 1)])) ^ 2))
loocv_rmse_final_mod
```

This is a much better value than our previous models tested, which is good for prediction purposes. The `model_add_mix` is our final choice. We'll assess it against the test set in the `results` section to get a real sense of how well this model is, instead of the relative improvements shown here. We'll also discuss the chosen model in general.

### Neighborhood Effect on Living Area Price

Now we can begin our exploratory data analysis. To examine the relationship between `Neighborhood` and `SalePrice`, we will perform a simple one-way ANOVA to determine whether belonging to different neighborhoods has any effect on `SalePrice` at all.

```{r}
neighborhood_oneway_anova = aov(SalePrice ~ Neighborhood, data = housing_data)
neigh_oneway_anova_summary = summary(neighborhood_oneway_anova)
```

A simple linear model would allow us to infer whether the Ground Living Area (`Gr.Liv.Area`) of a house has any relationship with `SalePrice`.

```{r}
livarea_model = lm(SalePrice ~ `Gr Liv Area`, data = housing_data)
livarea_model_summary = summary(livarea_model)
```

And, in order to infer whether or not a house's living area is more expensive in some neighborhoods than others, we'll perform Analysis of Co-Variance (ANCOVA) by including an interaction term between the continous variable `Gr.Liv.Area` and the categorical variable `Neighborhood`. If the slopes of `Gr.Liv.Area` are different (not parallel) for different neighborhoods, then we would notice a strong interaction between the two predictors.

```{r}
## This is a workaround for jtools library limitation
housing_data_alias = housing_data
housing_data_alias$Gr.Liv.Area = housing_data$`Gr Liv Area`

neigh_livarea_interaction_model = lm(SalePrice ~ Gr.Liv.Area*Neighborhood, data=housing_data_alias)
neigh_livarea_anova = anova(neigh_livarea_interaction_model)
p_value_neigh_livarea_interact =anova(neigh_livarea_interaction_model)[3,5]
```

We will also estimate actual slopes of the lines of `SalePrice` vs. `Gr.Liv.Area` for different neighborhoods to examine any differences.

```{r}
livarea_slopes_raw = sim_slopes(neigh_livarea_interaction_model, pred=Gr.Liv.Area, modx=Neighborhood,
                        johnson_neyman = FALSE,centered= "none", confint=T)

livarea_slopes = data.frame(livarea_slopes_raw$slopes[,1:5],stringsAsFactors=FALSE)
livarea_slopes[,2:5] = sapply(livarea_slopes[,2:5], as.double)
livarea_slopes[,2:5] = sapply(livarea_slopes[,2:5], signif, digits=4)

colnames(livarea_slopes)[1] = "Neighborhood"
colnames(livarea_slopes)[3] = "Std. Err."
colnames(livarea_slopes)[4] = "2.5%"
colnames(livarea_slopes)[5] = "97.5%"
```

Lastly, in order to determine whether the effect of `Gr.Liv.Area` on `SalePrice` is not explained by other predictors, we'll calculate the partial correlation coefficient between them with the effect of all other predictors removed. 

## Results

### Predictive model

The chosen model to predict Sale Price for the given dataset was stored in `model_add_mix`. It uses 20 predictors out of 80 originally available, which is aligned to our initial commitment towards not only getting a good model for prediction, but also a balanced model between prediction and explanation. 12 of those predictors are categorical and 8 numerical.

Below you can see the formula of the chosen model, which includes all the predictors and transformations used:

```{r}
model_add_mix$call
```

Since some of the predictors are categorical, then the number of coefficients in the model is bigger than the number of predictors used (due to the use of dummy variables). The model has in total `r length(model_add_mix$coefficients)` coefficients. 

To assess the final model, we can first focus on the prediction capabilities and then around explanatory capabilities.

From a prediction perspective we can first plot the fitted values versus the actual values to get a visual look of how the chosen model performs on the training set:

```{r fig.height=5, fig.width=10}
plot(train_hd$SalePrice, exp(fitted(model_add_mix)),
     xlab = "Actual price (dollars)",
     ylab = "Predicted price (dollars)",
     main = "Predicted vs actual price in dollars for training set",
     col = "orange")
abline(0, 1, lwd = 2, col = "dodgerblue")
```

Based on the previous plot, the points are very close to the identity line which means that the predictions are relatively similar to the actual values. It seems that there is a constant variance around the identity line (perhaps the epsilon of our model) which increases as the actual price increases.

Let's do the same for the test set. The predicted values are first stored in a variable so we can use it later to calculate more results.

```{r}
# Predict values
predicted = exp(predict(model_add_mix, newdata=test_hd))
```

We can now plot for the test set. These are unbiased results that can tell us a lot about the chosen model:

```{r fig.height=5, fig.width=10}
plot(test_hd$SalePrice, predicted,
     xlab = "Actual price (dollars)",
     ylab = "Predicted price (dollars)",
     main = "Predicted vs actual price in dollars for test set",
     col = "orange")
abline(0, 1, lwd = 2, col = "dodgerblue")
```

We can see that the behavior of this plot is really similar to the plot of the training set. The model seems to be doing a great job on predicting prices. For higher values, the deviation is bigger again.

Quantitatively, the chosen model has an adjusted $R^2$ of `r summary(model_add_mix)$adj.r.squared`. This is a decent value which can be interpreted as the model being able to explain a big part of the variation of the response. In terms of the test set we can calculate the RMSE which will simplify in a number what we saw in the previous plot:

```{r}
rmse_test = sqrt(mean((test_hd$SalePrice - predicted)^2))
rmse_test
```

The obtained RMSE for the test set is `r round(rmse_test)`. Let's compare it with the training RMSE. This will give us a clue around overfitting issues. Both results are put together in a table:

```{r}
rmse_train = sqrt(mean((train_hd$SalePrice - exp(fitted(model_add_mix)))^2))
rmse_train

library("knitr")
results = data.frame('Training' = c(rmse_train), 'Test' = c(rmse_test))
rownames(results) <- c("RMSE")
kable(results, format = "markdown")
```

The test RMSE is lower than the training RMSE. That's a good signal that the model is not overfitting the data. This has a positive impact on the predictive goal of our model.

Based on the previous plots of predicted values versus actual values we noticed that it seems that the model is better on predicting lower prices. Let's verify that by calculating the RMSE for house prices less than 200000 dollars:

```{r}
sqrt(mean((test_hd$SalePrice[test_hd$SalePrice < 200000] - predicted[which(test_hd$SalePrice < 200000)])^2))
```

Notice how the test RMSE is significantly reduced which proves that the model is doing better for lower priced houses.

Let's now focus on the explanatory capabilities of our model. Even though we were able to siginificantly reduced the amount of predictors used (20 out of 80), the model is not passing the assumptions tests, and there is an evident deviance on the normal Q-Q plot. Let's review this information:

```{r fig.height=5, fig.width=10}
get_overview(model_add_mix)
```

As you can see both assumption tests (Shapiro and Breusch) are returning really small values which is a clear violation of normality and constant variance. This means that any interpretation coming from the coefficients is suspect and this model shouldn't be used for explanatory purposes as it is now. Moreover, even if the assumptions weren't violated, the use of 20 predictors and 89 coefficients would make an explanation almost impossible to digest for a human.

```{r, eval=FALSE}
# install.packages("relaimpo")

library(relaimpo)
relImportance = calc.relimp(model_add_mix, type = c("lmg"), rela = TRUE) # calculate relative importance scaled to 100
sort(relImportance$lmg, decreasing=TRUE)  # relative importance
```

```{r}
predictors_mod = c("log(`Gr Liv Area`)", "Overall Qual", "Neighborhood", "Garage Cars", "Kitchen Qual", "Exter Qual", "MS SubClass", "log(`Total Bsmt SF`)", "Full Bath", "Year Remod/Add", "Fireplaces", "BsmtFin Type 1", "MS Zoning", "Mas Vnr Area", "Bsmt Exposure", "Mas Vnr Type", "Sale Condition", "Central Air", "Functional",  "Exter Cond")

values_mod = c(13.15, 12.16, 10.12, 6.89, 6.72, 6.68, 6.40, 5.96, 5.06, 4.87, 4.33, 3.45, 2.63, 2.58, 2.55, 2.18, 2.03, 1.03, 0.68, 0.51)

sum(0.131545225, 0.121646594, 0.101215099, 0.068901177, 0.067237683, 0.066841071, 0.064003974, 0.059600173, 0.050604498, 0.048683443, 0.043316993, 0.034459070, 0.026273611, 0.025847922, 0.025490972, 0.021807077, 0.020280687, 0.010313463, 0.006822245, 0.005109024)

mydata_mod = data.frame(predictors_mod, values_mod)
p = ggplot(mydata_mod, aes(reorder(predictors_mod, -values_mod), values_mod))
p +geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Predictors") + ylab("Predictor's %tage contribution to the model")


```



### Neighborhood Effect on Living Area Price

From our one-way ANOVA of `Neighborhood` and `SalePrice` in the `methods` section, it can easily be seen that the neighborhood had a significant effect on the price. We can also see this graphically using a box-plot.

```{r}
neigh_oneway_anova_summary
```

As you can see the p-value is really small, so we reject the null hypothesis, which means that `Neighborhood` does have an effect.

```{r fig.height=8, fig.width=10}
par(mar = c(5, 5, 4, 2), mgp = c(4, 1, 0)) ## Correct the margins
boxplot(SalePrice ~ Neighborhood, data = housing_data,las=2, col=2:8, pch=20, cex=.7,
        main="Sale Prices by Neighborhood",
        ylab="Sale Price (in US Dollars")
```

Similarly, it is easily shown that `Gr.Liv.Area` has an effect on `SalePrice`.

```{r fig.height=5, fig.width=10}
plot(SalePrice ~ `Gr Liv Area`, data = housing_data,
     xlab = "Living Area (square feet)",
     ylab = "Sale Price (US Dollars)",
     main = "Sale Price vs Ground Living Area",
     pch  = 20,
     cex  = .5,
     col  = "grey")
abline(livarea_model, col="darkorange", lwd=2)
```


However, we also observe that the interaction model between `Neighborhood` and `Gr.Liv.Area` yielded a near-zero p-value of `r signif(p_value_neigh_livarea_interact,4)`. This **suggests a significant interaction between the two predictors** when predicting `SalePrice`.

```{r}
signif(p_value_neigh_livarea_interact,4)
print(neigh_livarea_anova[-4,], signif.stars=FALSE)
```

Because of this, we obtain different slopes for `Gr.Liv.Area` depending on `Neighborhood`. Each of the slope estimates are the sum of the `Gr.Liv.Area` coefficient and its interaction term with the corresponding `Neighborhood` factor dummy variable. As with all estimates, we can calculate a mean and a confidence interval.

```{r fig.height=5, fig.width=10}

## Get the top 5 neighborhoods with the most houses
ordered_neigh = order(-table(housing_data$Neighborhood))

interact_plot(neigh_livarea_interaction_model, pred=Gr.Liv.Area,
              modx=Neighborhood,color.class="Qual1",
              modxvals = names(table(housing_data$Neighborhood)[ordered_neigh][1:6]),
              x.label="Ground Living Area (square feet)",
              y.label="Sale Price (US Dollars)") +
  ggtitle("Gr.Liv.Area Slopes of the 5 Neighborhoods with Most Sales" ) +
  theme(plot.title = element_text(hjust = 0.5))
```

```{r}
kable(livarea_slopes)
```

## Discussion

This section will be focused on analyzing the usefulness of the chosen model based on the results shown on the previous section, discuss the answers provided for the exploratory question, and some lessons learned while playing around with the data itself.

### Predictive model

#### Prediction

- The model was chosen by significantly reducing the number of predictors and combining several techniques studied in the course (forward selection process, correlation analysis, statistical tests, unusual observations analysis, etc) without sacrificing prediction usefulness. The chosen model returned the lowest LOOCV RMSE of all our analysis compared to the other models tested.
- Two plots were provided to compare predicted vs actual sale prices for both, the training set and the test set. There is a nice trend close to the identity line and an obvious increase of variance for expensive houses. From these results we can conclude that our model is better on predicting average priced houses.
- RMSE for both, training and test set, were provided. The RMSE of the test set (`r rmse_test`) is lower than the training set (`r rmse_train`) which give us confidence around not having any overfitting issue.
- RMSE is radically improved by filtering house prices lower than 200000 dollars. This confirms our conclusion around the model being better on predicting average priced houses.

```{r}
kable(model_performance,row.names = TRUE)
```


#### Explanation

- The normality and constant variance assumptions are violated by the model. Even though the goal of creating a model with a reduced amount of predictors was achieved, we couldn't improve the assumption metrics. In other words, the coefficients shouldn't be used to try to explain any relationship.

### Relationship between Neighborhood, Sale Price and Other Predictors

Having observed how both `Neighborhood` and `Gr.Liv.Area` interact with each other and influence `SalePrice`, it is important to highlight that it **does not imply a causal relationship** between them. This becomes more evident when we examine the partial correlation coefficient of `Gr.Liv.Area` and `SalePrice` with the effect of all other 78 predictors removed. We note that its magnitude is less than 0.01.

```{r}
without_livarea       = lm(SalePrice ~ . -`Gr Liv Area` , data=housing_data)
livarea_collinearity  = lm(`Gr Liv Area`~ . -SalePrice, data=housing_data)
(partial_corr_livarea_saleprice = cor(resid(without_livarea),resid(livarea_collinearity)))
```
 
Therefore, ground living area is collinear with many of the other predictors available in the dataset, and does not independently predict price. We can, however, **reject the null hypothesis** that the average price per square foot of living space is equal for all neighborhoods with a confidence level $\alpha= 0.01$.

### General

- The process of cleaning the data is not trivial at all. Even though this dataset was cured previously by the author, there are still many `NA`s and subtleties to play with. From removing non-relevant predictors (like identifiers or observation counters) to finding outliers and remove observations that can break prediction when dividing the test and the training set (e.g. some categories with only one observation).
- Exhaustive selection methods are not always an option. We started by trying using the `regsubsets` function with all the predictors, but the processing time was intractable We then decided on using a different approach combining transformations, a forward selection method, and a collinearity and correlation analysis. In other words, there is no a single recipe to find a 'good' model.
- A general exploration data is key before starting a model selection process. You need to know your data, check the description of the predictors, and use a bit of expertise and intuition to set a baseline model and iterate from there.

## Appendix

Here is a list of libraries that must be installed in order to run the RMD file attached to this assignment. Please make sure you have all of them installed:

```{r, eval = FALSE}
install.packages("readr")
install.packages("lmtest")
install.packages("faraway")
install.packages("knitr")
install.packages("ggplot2")
install.packages("jtools")
install.packages("qtlcharts")
install.packages("relaimpo")
```

## References

1. De Cock, Dean. (2011). *Ames, Iowa: Alternative to the Boston Housing Data as an End of Semester Regression Project*. Journal of Statistics Education.
2. *House Prices: Advanced Regression Techniques*. Obtained on July 9th, 2018, from: https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data
3. Dalpiaz, D. (2018). *Applied Statistics with R*. Obtained on July 9th, 2018, from: https://daviddalpiaz.github.io/appliedstats/
4. De Cock, Dean. (2011). *Ames, Iowa house price dataset*. Obtained on July 9th, 2018, from: http://www.amstat.org/publications/jse/v19n3/decock/AmesHousing.xls
5. De Cock, Dean. (2011). *Ames, Iowa house price dataset description*. Obtained on July 9th, 2018, from: https://ww2.amstat.org/publications/jse/v19n3/decock/DataDocumentation.txt
